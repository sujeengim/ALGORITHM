# 카운팅 배열 
- 배열의 **인덱스(Index)**를 데이터 값으로 사용하고, 

해당 인덱스의 **값(Value)**을 데이터의 **출현 횟수(빈도수)**로 기록하여 데이터를 정리

EX. $\text{Count}[3] = 5$는 숫자 3이 5번 나왔음을 의미


- 일종의 해시 테이블(Hash Table) 역할을 수행하지만, 별도의 해시 함수 없이 배열의 인덱스 자체가 키(Key)가 됩니다.

- 탐색 속도 : o(1)
- 정렬 속도 : o(데이터개수+값의범위)

- 사용 조건
카운팅 배열은 다음과 같은 조건에서 가장 효율적입니다.

1) 데이터 값의 범위가 작을 때: 

인덱스를 값으로 사용해야 하므로, 데이터 값의 최솟값과 최댓값 사이의 간격(범위)이 너무 크면 배열의 크기가 비효율적으로 커집니다. (예: 1부터 100까지의 숫자는 적합)

2) 데이터가 정수(Integer)일 때: 

배열 인덱스는 정수여야 하므로, 일반적으로 정수형 데이터를 처리하는 데 사용됩니다.

<img width="828" height="176" alt="image" src="https://github.com/user-attachments/assets/c9124cff-8892-4ab9-ad55-652981839b93" />


세개의 정답 코드를 발견했다. 

# 1 : 처음 구현한 시간복잡도 높음
```python
T = int(input())
for test_case in range(1, T + 1):
    dump = int(input())
    list100 = list(map(int, input().split()))

    for _ in range(dump): #1000회
        if max(list100)-min(list100) <= 1: #100회
            break
        min_idx = list100.index(min(list100))
        max_idx = list100.index(max(list100))
        list100[max_idx] -= 1
        list100[min_idx] += 1

    print(f"#{test_case} {max(list100)-min(list100)}")

```

# 2 : 카운팅 정렬 사용하여 위코드보다 속도 빠름 
```python
# 카운팅 정렬 사용 
T = int(input())
for test_case in range(1, T + 1):
    dump = int(input())
    list100 = list(map(int, input().split()))
    counts = [0]*101
    for v in list100:
        counts[v] += 1

    min_idx = 1
    while counts[min_idx]==0:
        min_idx += 1
    max_idx = 100
    while counts[max_idx]==0:
        max_idx -= 1

    for _ in range(dump):
        if max_idx - min_idx <= 1:
            break
        counts[max_idx] -= 1
        counts[max_idx-1] += 1
        counts[min_idx] -= 1
        counts[min_idx+1] += 1

        if counts[min_idx] == 0:
            min_idx += 1
        if counts[max_idx] == 0:
            max_idx -= 1

    print(f"#{test_case} {max_idx-min_idx}")

```

# 3 : 사람들이 어이없어 하는 코드 
```python
for test_case in range(1, 11):
    dmp = int(input())
    nums = list(map(int, input().split()))

    for x in range(dmp):
        nums.sort()
        nums[0] += 1
        nums[-1] -= 1
    
    print(f"#{test_case} {max(nums)-min(nums)}")
```
